#!/bin/sh

__get_argtype() {
  #
  # Checks whether or not ${1} is in the comma separated list of strings of ${2}.
  #
  # If the loop is broken, a match was found and the function returns 0; if
  # exhausted, the function returns 1.
  #

  __get_argtype_target="${1}"
  __get_argtype_list="${2}"
  __get_argtype_elem=""
  while [ -n "${__get_argtype_list}" ]; do
    #
    # The string deletions below are as follows:
    #
    # The first one deletes all but the first element of the passed list.
    #
    # The second one, the first element.
    #
    # The third, the comma after the first element. This deletion is done
    # separately, because of the last element: when it's reached, it contains no
    # ',' after itself, so adding a ',' to the pattern would cause it to not be
    # deleted and the loop to never finish. By separating the deletion of the
    # ',', the last item can be deleted.
    #
    __get_argtype_elem="${__get_argtype_list%%,*}"
    __get_argtype_list="${__get_argtype_list#"${__get_argtype_elem}"}"
    __get_argtype_list="${__get_argtype_list#,}"

    #
    # Comparison with The Target
    #
    # Since the passed options do not contain a ':' at the end, it must be
    # removed from the current element.
    #
    case "${__get_argtype_elem%:}" in
      "${__get_argtype_target}")
        [ -z "${__get_argtype_elem#*:}" ] && printf "reqarg" || printf "noarg"
        return 0
        ;;
    esac
  done

  return 1
}

gepsh() {
  #
  # This function takes three arguments:
  #
  # gepsh "sopts" "lopts" "arguments"
  #
  # The first one is a comma separated list of one character strings that may
  # or not contain a ':' at the end --- e. g., "a,b:,c:", ---, which indicates
  # that the option takes an argument.
  #
  # The second one is also a comma separated list of strings with the
  # same idiosyncrasies, however, they must be more than one character of
  # length, for example, "a-long,b-long:,c-long:".
  #
  # Realize that for an option to be correctly parsed, both options must
  # indicate if it takes or not an argument. Moreover, spaces between the
  # options are not supported, hence, "a,b:,c" and "a-long,b-long:,c-long" are
  # valid, while "a , b:, c" and " a-long , b-long: , c-long" are not.
  # 
  # If the program contains no short or long options, a comma should be passed
  # in their place:
  #
  # gepsh "," "a-long" "arguments"
  #
  # The last argument are the arguments to be parsed.
  #
  # Do note that that this implementation of an argument parser follows the
  # behavior of GNU Getopt with the `POSIXLY_CORRECT` environment variable set:
  # the first positional argument reached will make all of those after it to be
  # treated like positional arguments.
  #
  sopts="${1}"
  lopts="${2}"
  shift 2
  gepsh_treat_as_posargs=""

  #
  # This function only prints one time to stdout: after the loop, when all
  # options and arguments are correctly parsed. This is done to avoid mixing the
  # captured error message with validated arguments.
  #
  gepsh_stdout=""

  while [ "${#}" -gt 0 ]; do
    opt=""
    #
    # For info on this parameter expansion, see `Positional Arguments` below.
    #
    case "${gepsh_treat_as_posargs:-"${1}"}" in
      #
      # Long Options
      #
      # Even though these options must be at least two character long, the check
      # is done against options with the double dashes and a single char too.
      # Because of this, they can be invalidated.
      #
      --?*)
        #
        # Firstly, the double dashes are removed, since only the option name is
        # compared to check its validity; secondly, the argument preceded by a
        # '=' is removed: realize that, when the option is not passed in the
        # "key=value" format, such string deletion will do nothing.
        #
        opt="${1#--}"
        opt="${opt%%=*}"
        ;;
      #
      # Short Options
      #
      # To avoid that the special positional argument ("--") is caught here, the
      # [!-] is used after the first dash; with this the former may be excluded.
      # Moreover, a '*' is used instead of a '?' for this case to be able to
      # caught short options with either arguments --- e. g., "-aArgOfA" ---,
      # options --- e. g., "-abc" --- or both --- e. g., "-abcArgOfC" ---
      # conjoined to itself.
      #
      -[!-]*);;
      #
      # Positional Arguments
      #
      # Since this parser follows, partialy, the behavior of `GNU getopt` when
      # the `POSIXLY_CORRECT` variable is set, at the first positional argument,
      # all of the remaining ones, whatever they are, shall be considered also
      # positional arguments. Thus, the arguments:
      #
      # `-abc --d-long ArgOfD PosArg1 -efg --h-long=ArgOfH`
      #
      # would be divided in:
      #
      # 1) Optional arguments and its positional arguments:
      # `"-a" "-b" "-c" "--d-long" "ArgOfD"`
      # 
      # 2) Positional arguments:
      # `"PosArg1" "-efg" "--h-long=ArgOfH"`
      #
      # To achieve this behavior, there must be a flag which is set when the
      # first positional argument is found. 
      # Such a flag is `gepsh_treat_as_posargs`.
      #
      # Its use on the `WORD` argument of the case statement has the following
      # rationale: all that is not a long option (`--?*`) or a short option
      # (`-[!-]*`) is a positional argument, in consequence, the value `1` ---
      # `gepsh_treat_as_posargs` value when set --- will always be treated as an
      # positional argument.
      #
      # Realize that this matching does not alter the value of `${1}`, only the
      # `WORD` argument of the case statement.
      #
      *)
        #
        # When a program is looping over the parsed options, the "--" indicates
        # that, with it, the positional arguments begin.
        #
        [ -z "${gepsh_treat_as_posargs}" ] && {
          gepsh_stdout="$(printf "%s \"%s\"" "${gepsh_stdout}" "--")"
        }
        gepsh_stdout="$(printf "%s \"%s\"" "${gepsh_stdout}" "${1}")"
        gepsh_treat_as_posargs="1"
        ;;
    esac
    shift
  done
  printf "%s\n" "${gepsh_stdout}"
}
