#!/bin/sh

__is_in() {
  #
  # Checks whether or not ${1} is in the comma separated list of strings of ${2}.
  #
  # If the loop is broken, a match was found and the function returns 0; if
  # exhausted, the function returns 1.
  #

  __is_in_target="${1}"
  __is_in_list="${2}"
  __is_in_elem=""
  while [ -n "${__is_in_list}" ]; do
    #
    # The string deletions below are as follows:
    #
    # The first one deletes all but the first element of the passed list.
    #
    # The second one, the first element.
    #
    # The third, the comma after the first element. This deletion is done
    # separately, because of the last element: when it's reached, it contains no
    # ',' after itself, so adding a ',' to the pattern would cause it to not be
    # deleted and the loop to never finish. By separating the deletion of the
    # ',', the last item can be deleted.
    #
    __is_in_elem="${__is_in_list%%,*}"
    __is_in_list="${__is_in_list#"${__is_in_elem}"}"
    __is_in_list="${__is_in_list#,}"

    #
    # Comparison with The Target
    #
    # Since the passed options do not contain a ':' at the end, it must be
    # removed from the current element.
    #
    case "${__is_in_elem%:}" in
      "${__is_in_target}")
        [ -z "${__is_in_elem#*:}" ] && printf "reqarg" || printf "noarg"
        return 0
        ;;
    esac
  done

  return 1
}

gepsh() {
  #
  # This function takes three arguments:
  #
  # gepsh "sopts" "lopts" "arguments"
  #
  # The first one is a comma separated list of one character strings that may
  # or not contain a ':' at the end --- e. g., "a,b:,c:", ---, which indicates
  # that the option takes an argument.
  #
  # The second one is also a comma separated list of strings with the
  # same idiosyncrasies, however, they must be more than one character of
  # length, for example, "a-long,b-long:,c-long:".
  #
  # Realize that for an option to be correctly parsed, both options must
  # indicate if it takes or not an argument. Moreover, spaces between the
  # options are not supported, hence, "a,b:,c" and "a-long,b-long:,c-long" are
  # valid, while "a , b:, c" and " a-long , b-long: , c-long" are not.
  # 
  # If the program contains no short or long options, a comma should be passed
  # in their place:
  #
  # gepsh "," "a-long" "arguments"
  #
  # The last argument are the arguments to be parsed.
  #
  # Do note that that this implementation of an argument parser follows the
  # behavior of GNU Getopt with the `POSIXLY_CORRECT` environment variable set:
  # the first positional argument reached will make all of those after it to be
  # treated like positional arguments.
  #
  gepsh_progname="gepsh"
  sopts="${1}"
  lopts="${2}"
  shift 2

  #
  # Iterate over every argument in "${@}"
  #
  while [ "${#}" -gt 0 ]; do
    opt=""
    case "${1}" in
      #
      # Long Options
      #
      # Even though these options must be at least two character long, the check
      # is done against options with the double dashes and a single char too.
      # Because of this, they can be invalidated.
      #
      --?*)
        #
        # Firstly, the double dashes are removed, since only the option name is
        # compared to check its validity; secondly, the argument preceded by a
        # '=' is removed: realize that, when the option is not passed in the
        # "key=value" format, such string deletion will do nothing.
        #
        opt="${1#--}"
        opt="${opt%%=*}"
        ;;
      #
      # Short Options
      #
      # To avoid that the special positional argument ("--") is caught here, the
      # [!-] is used after the first dash; with this the former may be excluded.
      # Moreover, a '*' is used instead of a '?' for this case to be able to
      # caught short options with either arguments --- e. g., "-aArgOfA" ---,
      # options --- e. g., "-abc" --- or both --- e. g., "-abcArgOfC" ---
      # conjoined to itself.
      #
      -[!-]*);;
    esac
    shift
  done
}
